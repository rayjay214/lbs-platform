// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace.proto

#ifndef PROTOBUF_trace_2eproto__INCLUDED
#define PROTOBUF_trace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trace_2eproto();
void protobuf_AssignDesc_trace_2eproto();
void protobuf_ShutdownFile_trace_2eproto();

class LoginReq;
class LoginResp;
class GnsInfoReq;
class CfgInfoReq;
class CfgInfoResp;
class LogInfo;
class GetLogReq;
class GetLogRespOld;
class LogText;
class GetLogResp;
class HeartBeatMsg;
class ClearSessionReq;

// ===================================================================

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();
  
  LoginReq(const LoginReq& from);
  
  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();
  
  void Swap(LoginReq* other);
  
  // implements Message ----------------------------------------------
  
  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional int32 fd = 3;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 3;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 4;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 4;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.LoginReq)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_name_;
  ::std::string* password_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginResp : public ::google::protobuf::Message {
 public:
  LoginResp();
  virtual ~LoginResp();
  
  LoginResp(const LoginResp& from);
  
  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResp& default_instance();
  
  void Swap(LoginResp* other);
  
  // implements Message ----------------------------------------------
  
  LoginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResp& from);
  void MergeFrom(const LoginResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional int32 fd = 2;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 2;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 3;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 3;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // optional int32 ret = 4;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 4;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);
  
  // optional string ret_msg = 5;
  inline bool has_ret_msg() const;
  inline void clear_ret_msg();
  static const int kRetMsgFieldNumber = 5;
  inline const ::std::string& ret_msg() const;
  inline void set_ret_msg(const ::std::string& value);
  inline void set_ret_msg(const char* value);
  inline void set_ret_msg(const char* value, size_t size);
  inline ::std::string* mutable_ret_msg();
  inline ::std::string* release_ret_msg();
  
  // @@protoc_insertion_point(class_scope:pb.LoginResp)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ret_msg();
  inline void clear_has_ret_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 req_begin_time_;
  ::std::string* ret_msg_;
  ::google::protobuf::int32 ret_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResp* default_instance_;
};
// -------------------------------------------------------------------

class GnsInfoReq : public ::google::protobuf::Message {
 public:
  GnsInfoReq();
  virtual ~GnsInfoReq();
  
  GnsInfoReq(const GnsInfoReq& from);
  
  inline GnsInfoReq& operator=(const GnsInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GnsInfoReq& default_instance();
  
  void Swap(GnsInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  GnsInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GnsInfoReq& from);
  void MergeFrom(const GnsInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string gns_name = 1;
  inline int gns_name_size() const;
  inline void clear_gns_name();
  static const int kGnsNameFieldNumber = 1;
  inline const ::std::string& gns_name(int index) const;
  inline ::std::string* mutable_gns_name(int index);
  inline void set_gns_name(int index, const ::std::string& value);
  inline void set_gns_name(int index, const char* value);
  inline void set_gns_name(int index, const char* value, size_t size);
  inline ::std::string* add_gns_name();
  inline void add_gns_name(const ::std::string& value);
  inline void add_gns_name(const char* value);
  inline void add_gns_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& gns_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_gns_name();
  
  // repeated string ip_port = 2;
  inline int ip_port_size() const;
  inline void clear_ip_port();
  static const int kIpPortFieldNumber = 2;
  inline const ::std::string& ip_port(int index) const;
  inline ::std::string* mutable_ip_port(int index);
  inline void set_ip_port(int index, const ::std::string& value);
  inline void set_ip_port(int index, const char* value);
  inline void set_ip_port(int index, const char* value, size_t size);
  inline ::std::string* add_ip_port();
  inline void add_ip_port(const ::std::string& value);
  inline void add_ip_port(const char* value);
  inline void add_ip_port(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_port() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_port();
  
  // @@protoc_insertion_point(class_scope:pb.GnsInfoReq)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> gns_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static GnsInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CfgInfoReq : public ::google::protobuf::Message {
 public:
  CfgInfoReq();
  virtual ~CfgInfoReq();
  
  CfgInfoReq(const CfgInfoReq& from);
  
  inline CfgInfoReq& operator=(const CfgInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CfgInfoReq& default_instance();
  
  void Swap(CfgInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  CfgInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CfgInfoReq& from);
  void MergeFrom(const CfgInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional int32 p1 = 2;
  inline bool has_p1() const;
  inline void clear_p1();
  static const int kP1FieldNumber = 2;
  inline ::google::protobuf::int32 p1() const;
  inline void set_p1(::google::protobuf::int32 value);
  
  // optional int64 p2 = 3;
  inline bool has_p2() const;
  inline void clear_p2();
  static const int kP2FieldNumber = 3;
  inline ::google::protobuf::int64 p2() const;
  inline void set_p2(::google::protobuf::int64 value);
  
  // optional string p3 = 4;
  inline bool has_p3() const;
  inline void clear_p3();
  static const int kP3FieldNumber = 4;
  inline const ::std::string& p3() const;
  inline void set_p3(const ::std::string& value);
  inline void set_p3(const char* value);
  inline void set_p3(const char* value, size_t size);
  inline ::std::string* mutable_p3();
  inline ::std::string* release_p3();
  
  // optional string gns_name = 5;
  inline bool has_gns_name() const;
  inline void clear_gns_name();
  static const int kGnsNameFieldNumber = 5;
  inline const ::std::string& gns_name() const;
  inline void set_gns_name(const ::std::string& value);
  inline void set_gns_name(const char* value);
  inline void set_gns_name(const char* value, size_t size);
  inline ::std::string* mutable_gns_name();
  inline ::std::string* release_gns_name();
  
  // optional string ip_port = 6;
  inline bool has_ip_port() const;
  inline void clear_ip_port();
  static const int kIpPortFieldNumber = 6;
  inline const ::std::string& ip_port() const;
  inline void set_ip_port(const ::std::string& value);
  inline void set_ip_port(const char* value);
  inline void set_ip_port(const char* value, size_t size);
  inline ::std::string* mutable_ip_port();
  inline ::std::string* release_ip_port();
  
  // optional int32 fd = 7;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 7;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 8;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 8;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.CfgInfoReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_p1();
  inline void clear_has_p1();
  inline void set_has_p2();
  inline void clear_has_p2();
  inline void set_has_p3();
  inline void clear_has_p3();
  inline void set_has_gns_name();
  inline void clear_has_gns_name();
  inline void set_has_ip_port();
  inline void clear_has_ip_port();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::google::protobuf::int64 p2_;
  ::std::string* p3_;
  ::google::protobuf::int32 p1_;
  ::google::protobuf::int32 fd_;
  ::std::string* gns_name_;
  ::std::string* ip_port_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static CfgInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class CfgInfoResp : public ::google::protobuf::Message {
 public:
  CfgInfoResp();
  virtual ~CfgInfoResp();
  
  CfgInfoResp(const CfgInfoResp& from);
  
  inline CfgInfoResp& operator=(const CfgInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CfgInfoResp& default_instance();
  
  void Swap(CfgInfoResp* other);
  
  // implements Message ----------------------------------------------
  
  CfgInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CfgInfoResp& from);
  void MergeFrom(const CfgInfoResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);
  
  // optional string ret_msg = 2;
  inline bool has_ret_msg() const;
  inline void clear_ret_msg();
  static const int kRetMsgFieldNumber = 2;
  inline const ::std::string& ret_msg() const;
  inline void set_ret_msg(const ::std::string& value);
  inline void set_ret_msg(const char* value);
  inline void set_ret_msg(const char* value, size_t size);
  inline ::std::string* mutable_ret_msg();
  inline ::std::string* release_ret_msg();
  
  // optional int32 fd = 3;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 3;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 4;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 4;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.CfgInfoResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ret_msg();
  inline void clear_has_ret_msg();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ret_msg_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static CfgInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class LogInfo : public ::google::protobuf::Message {
 public:
  LogInfo();
  virtual ~LogInfo();
  
  LogInfo(const LogInfo& from);
  
  inline LogInfo& operator=(const LogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInfo& default_instance();
  
  void Swap(LogInfo* other);
  
  // implements Message ----------------------------------------------
  
  LogInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInfo& from);
  void MergeFrom(const LogInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string gns_name = 1;
  inline bool has_gns_name() const;
  inline void clear_gns_name();
  static const int kGnsNameFieldNumber = 1;
  inline const ::std::string& gns_name() const;
  inline void set_gns_name(const ::std::string& value);
  inline void set_gns_name(const char* value);
  inline void set_gns_name(const char* value, size_t size);
  inline ::std::string* mutable_gns_name();
  inline ::std::string* release_gns_name();
  
  // optional string ip_port = 2;
  inline bool has_ip_port() const;
  inline void clear_ip_port();
  static const int kIpPortFieldNumber = 2;
  inline const ::std::string& ip_port() const;
  inline void set_ip_port(const ::std::string& value);
  inline void set_ip_port(const char* value);
  inline void set_ip_port(const char* value, size_t size);
  inline ::std::string* mutable_ip_port();
  inline ::std::string* release_ip_port();
  
  // optional string session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string log_text = 4;
  inline bool has_log_text() const;
  inline void clear_log_text();
  static const int kLogTextFieldNumber = 4;
  inline const ::std::string& log_text() const;
  inline void set_log_text(const ::std::string& value);
  inline void set_log_text(const char* value);
  inline void set_log_text(const char* value, size_t size);
  inline ::std::string* mutable_log_text();
  inline ::std::string* release_log_text();
  
  // @@protoc_insertion_point(class_scope:pb.LogInfo)
 private:
  inline void set_has_gns_name();
  inline void clear_has_gns_name();
  inline void set_has_ip_port();
  inline void clear_has_ip_port();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_log_text();
  inline void clear_has_log_text();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* gns_name_;
  ::std::string* ip_port_;
  ::std::string* session_id_;
  ::std::string* log_text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static LogInfo* default_instance_;
};
// -------------------------------------------------------------------

class GetLogReq : public ::google::protobuf::Message {
 public:
  GetLogReq();
  virtual ~GetLogReq();
  
  GetLogReq(const GetLogReq& from);
  
  inline GetLogReq& operator=(const GetLogReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLogReq& default_instance();
  
  void Swap(GetLogReq* other);
  
  // implements Message ----------------------------------------------
  
  GetLogReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLogReq& from);
  void MergeFrom(const GetLogReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string gns_name = 2;
  inline bool has_gns_name() const;
  inline void clear_gns_name();
  static const int kGnsNameFieldNumber = 2;
  inline const ::std::string& gns_name() const;
  inline void set_gns_name(const ::std::string& value);
  inline void set_gns_name(const char* value);
  inline void set_gns_name(const char* value, size_t size);
  inline ::std::string* mutable_gns_name();
  inline ::std::string* release_gns_name();
  
  // optional string ip_port = 3;
  inline bool has_ip_port() const;
  inline void clear_ip_port();
  static const int kIpPortFieldNumber = 3;
  inline const ::std::string& ip_port() const;
  inline void set_ip_port(const ::std::string& value);
  inline void set_ip_port(const char* value);
  inline void set_ip_port(const char* value, size_t size);
  inline ::std::string* mutable_ip_port();
  inline ::std::string* release_ip_port();
  
  // optional int32 seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);
  
  // optional int32 fd = 5;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 5;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 6;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 6;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.GetLogReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_gns_name();
  inline void clear_has_gns_name();
  inline void set_has_ip_port();
  inline void clear_has_ip_port();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  ::std::string* gns_name_;
  ::std::string* ip_port_;
  ::google::protobuf::int32 seq_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static GetLogReq* default_instance_;
};
// -------------------------------------------------------------------

class GetLogRespOld : public ::google::protobuf::Message {
 public:
  GetLogRespOld();
  virtual ~GetLogRespOld();
  
  GetLogRespOld(const GetLogRespOld& from);
  
  inline GetLogRespOld& operator=(const GetLogRespOld& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLogRespOld& default_instance();
  
  void Swap(GetLogRespOld* other);
  
  // implements Message ----------------------------------------------
  
  GetLogRespOld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLogRespOld& from);
  void MergeFrom(const GetLogRespOld& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);
  
  // optional string ret_msg = 2;
  inline bool has_ret_msg() const;
  inline void clear_ret_msg();
  static const int kRetMsgFieldNumber = 2;
  inline const ::std::string& ret_msg() const;
  inline void set_ret_msg(const ::std::string& value);
  inline void set_ret_msg(const char* value);
  inline void set_ret_msg(const char* value, size_t size);
  inline ::std::string* mutable_ret_msg();
  inline ::std::string* release_ret_msg();
  
  // optional string log_text = 3;
  inline bool has_log_text() const;
  inline void clear_log_text();
  static const int kLogTextFieldNumber = 3;
  inline const ::std::string& log_text() const;
  inline void set_log_text(const ::std::string& value);
  inline void set_log_text(const char* value);
  inline void set_log_text(const char* value, size_t size);
  inline ::std::string* mutable_log_text();
  inline ::std::string* release_log_text();
  
  // optional int32 cur_len = 4;
  inline bool has_cur_len() const;
  inline void clear_cur_len();
  static const int kCurLenFieldNumber = 4;
  inline ::google::protobuf::int32 cur_len() const;
  inline void set_cur_len(::google::protobuf::int32 value);
  
  // optional int32 fd = 5;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 5;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 6;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 6;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:pb.GetLogRespOld)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ret_msg();
  inline void clear_has_ret_msg();
  inline void set_has_log_text();
  inline void clear_has_log_text();
  inline void set_has_cur_len();
  inline void clear_has_cur_len();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ret_msg_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 cur_len_;
  ::std::string* log_text_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static GetLogRespOld* default_instance_;
};
// -------------------------------------------------------------------

class LogText : public ::google::protobuf::Message {
 public:
  LogText();
  virtual ~LogText();
  
  LogText(const LogText& from);
  
  inline LogText& operator=(const LogText& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogText& default_instance();
  
  void Swap(LogText* other);
  
  // implements Message ----------------------------------------------
  
  LogText* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogText& from);
  void MergeFrom(const LogText& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ip_port = 1;
  inline bool has_ip_port() const;
  inline void clear_ip_port();
  static const int kIpPortFieldNumber = 1;
  inline const ::std::string& ip_port() const;
  inline void set_ip_port(const ::std::string& value);
  inline void set_ip_port(const char* value);
  inline void set_ip_port(const char* value, size_t size);
  inline ::std::string* mutable_ip_port();
  inline ::std::string* release_ip_port();
  
  // optional string gns_name = 2;
  inline bool has_gns_name() const;
  inline void clear_gns_name();
  static const int kGnsNameFieldNumber = 2;
  inline const ::std::string& gns_name() const;
  inline void set_gns_name(const ::std::string& value);
  inline void set_gns_name(const char* value);
  inline void set_gns_name(const char* value, size_t size);
  inline ::std::string* mutable_gns_name();
  inline ::std::string* release_gns_name();
  
  // repeated string text = 3;
  inline int text_size() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text(int index) const;
  inline ::std::string* mutable_text(int index);
  inline void set_text(int index, const ::std::string& value);
  inline void set_text(int index, const char* value);
  inline void set_text(int index, const char* value, size_t size);
  inline ::std::string* add_text();
  inline void add_text(const ::std::string& value);
  inline void add_text(const char* value);
  inline void add_text(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& text() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_text();
  
  // @@protoc_insertion_point(class_scope:pb.LogText)
 private:
  inline void set_has_ip_port();
  inline void clear_has_ip_port();
  inline void set_has_gns_name();
  inline void clear_has_gns_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_port_;
  ::std::string* gns_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> text_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static LogText* default_instance_;
};
// -------------------------------------------------------------------

class GetLogResp : public ::google::protobuf::Message {
 public:
  GetLogResp();
  virtual ~GetLogResp();
  
  GetLogResp(const GetLogResp& from);
  
  inline GetLogResp& operator=(const GetLogResp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLogResp& default_instance();
  
  void Swap(GetLogResp* other);
  
  // implements Message ----------------------------------------------
  
  GetLogResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetLogResp& from);
  void MergeFrom(const GetLogResp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);
  
  // optional string ret_msg = 2;
  inline bool has_ret_msg() const;
  inline void clear_ret_msg();
  static const int kRetMsgFieldNumber = 2;
  inline const ::std::string& ret_msg() const;
  inline void set_ret_msg(const ::std::string& value);
  inline void set_ret_msg(const char* value);
  inline void set_ret_msg(const char* value, size_t size);
  inline ::std::string* mutable_ret_msg();
  inline ::std::string* release_ret_msg();
  
  // optional int32 fd = 3;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 3;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // optional int32 req_begin_time = 4;
  inline bool has_req_begin_time() const;
  inline void clear_req_begin_time();
  static const int kReqBeginTimeFieldNumber = 4;
  inline ::google::protobuf::int32 req_begin_time() const;
  inline void set_req_begin_time(::google::protobuf::int32 value);
  
  // repeated .pb.LogText log_text = 5;
  inline int log_text_size() const;
  inline void clear_log_text();
  static const int kLogTextFieldNumber = 5;
  inline const ::pb::LogText& log_text(int index) const;
  inline ::pb::LogText* mutable_log_text(int index);
  inline ::pb::LogText* add_log_text();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::LogText >&
      log_text() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::LogText >*
      mutable_log_text();
  
  // @@protoc_insertion_point(class_scope:pb.GetLogResp)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_ret_msg();
  inline void clear_has_ret_msg();
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_req_begin_time();
  inline void clear_has_req_begin_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ret_msg_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 fd_;
  ::google::protobuf::RepeatedPtrField< ::pb::LogText > log_text_;
  ::google::protobuf::int32 req_begin_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static GetLogResp* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatMsg : public ::google::protobuf::Message {
 public:
  HeartBeatMsg();
  virtual ~HeartBeatMsg();
  
  HeartBeatMsg(const HeartBeatMsg& from);
  
  inline HeartBeatMsg& operator=(const HeartBeatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatMsg& default_instance();
  
  void Swap(HeartBeatMsg* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeatMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatMsg& from);
  void MergeFrom(const HeartBeatMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline const ::std::string& reserve() const;
  inline void set_reserve(const ::std::string& value);
  inline void set_reserve(const char* value);
  inline void set_reserve(const char* value, size_t size);
  inline ::std::string* mutable_reserve();
  inline ::std::string* release_reserve();
  
  // @@protoc_insertion_point(class_scope:pb.HeartBeatMsg)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* reserve_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeatMsg* default_instance_;
};
// -------------------------------------------------------------------

class ClearSessionReq : public ::google::protobuf::Message {
 public:
  ClearSessionReq();
  virtual ~ClearSessionReq();
  
  ClearSessionReq(const ClearSessionReq& from);
  
  inline ClearSessionReq& operator=(const ClearSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearSessionReq& default_instance();
  
  void Swap(ClearSessionReq* other);
  
  // implements Message ----------------------------------------------
  
  ClearSessionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClearSessionReq& from);
  void MergeFrom(const ClearSessionReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // @@protoc_insertion_point(class_scope:pb.ClearSessionReq)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();
  
  void InitAsDefaultInstance();
  static ClearSessionReq* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginReq

// optional string user_name = 1;
inline bool LoginReq::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& LoginReq::user_name() const {
  return *user_name_;
}
inline void LoginReq::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginReq::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginReq::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* LoginReq::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 2;
inline bool LoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginReq::password() const {
  return *password_;
}
inline void LoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fd = 3;
inline bool LoginReq::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 LoginReq::fd() const {
  return fd_;
}
inline void LoginReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 4;
inline bool LoginReq::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 LoginReq::req_begin_time() const {
  return req_begin_time_;
}
inline void LoginReq::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// -------------------------------------------------------------------

// LoginResp

// optional string session_id = 1;
inline bool LoginResp::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResp::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResp::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginResp::session_id() const {
  return *session_id_;
}
inline void LoginResp::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginResp::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LoginResp::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResp::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LoginResp::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fd = 2;
inline bool LoginResp::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResp::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 LoginResp::fd() const {
  return fd_;
}
inline void LoginResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 3;
inline bool LoginResp::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResp::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResp::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResp::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 LoginResp::req_begin_time() const {
  return req_begin_time_;
}
inline void LoginResp::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// optional int32 ret = 4;
inline bool LoginResp::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResp::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 LoginResp::ret() const {
  return ret_;
}
inline void LoginResp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional string ret_msg = 5;
inline bool LoginResp::has_ret_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResp::set_has_ret_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResp::clear_has_ret_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResp::clear_ret_msg() {
  if (ret_msg_ != &::google::protobuf::internal::kEmptyString) {
    ret_msg_->clear();
  }
  clear_has_ret_msg();
}
inline const ::std::string& LoginResp::ret_msg() const {
  return *ret_msg_;
}
inline void LoginResp::set_ret_msg(const ::std::string& value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void LoginResp::set_ret_msg(const char* value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void LoginResp::set_ret_msg(const char* value, size_t size) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResp::mutable_ret_msg() {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  return ret_msg_;
}
inline ::std::string* LoginResp::release_ret_msg() {
  clear_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_msg_;
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GnsInfoReq

// repeated string gns_name = 1;
inline int GnsInfoReq::gns_name_size() const {
  return gns_name_.size();
}
inline void GnsInfoReq::clear_gns_name() {
  gns_name_.Clear();
}
inline const ::std::string& GnsInfoReq::gns_name(int index) const {
  return gns_name_.Get(index);
}
inline ::std::string* GnsInfoReq::mutable_gns_name(int index) {
  return gns_name_.Mutable(index);
}
inline void GnsInfoReq::set_gns_name(int index, const ::std::string& value) {
  gns_name_.Mutable(index)->assign(value);
}
inline void GnsInfoReq::set_gns_name(int index, const char* value) {
  gns_name_.Mutable(index)->assign(value);
}
inline void GnsInfoReq::set_gns_name(int index, const char* value, size_t size) {
  gns_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GnsInfoReq::add_gns_name() {
  return gns_name_.Add();
}
inline void GnsInfoReq::add_gns_name(const ::std::string& value) {
  gns_name_.Add()->assign(value);
}
inline void GnsInfoReq::add_gns_name(const char* value) {
  gns_name_.Add()->assign(value);
}
inline void GnsInfoReq::add_gns_name(const char* value, size_t size) {
  gns_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GnsInfoReq::gns_name() const {
  return gns_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GnsInfoReq::mutable_gns_name() {
  return &gns_name_;
}

// repeated string ip_port = 2;
inline int GnsInfoReq::ip_port_size() const {
  return ip_port_.size();
}
inline void GnsInfoReq::clear_ip_port() {
  ip_port_.Clear();
}
inline const ::std::string& GnsInfoReq::ip_port(int index) const {
  return ip_port_.Get(index);
}
inline ::std::string* GnsInfoReq::mutable_ip_port(int index) {
  return ip_port_.Mutable(index);
}
inline void GnsInfoReq::set_ip_port(int index, const ::std::string& value) {
  ip_port_.Mutable(index)->assign(value);
}
inline void GnsInfoReq::set_ip_port(int index, const char* value) {
  ip_port_.Mutable(index)->assign(value);
}
inline void GnsInfoReq::set_ip_port(int index, const char* value, size_t size) {
  ip_port_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GnsInfoReq::add_ip_port() {
  return ip_port_.Add();
}
inline void GnsInfoReq::add_ip_port(const ::std::string& value) {
  ip_port_.Add()->assign(value);
}
inline void GnsInfoReq::add_ip_port(const char* value) {
  ip_port_.Add()->assign(value);
}
inline void GnsInfoReq::add_ip_port(const char* value, size_t size) {
  ip_port_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GnsInfoReq::ip_port() const {
  return ip_port_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GnsInfoReq::mutable_ip_port() {
  return &ip_port_;
}

// -------------------------------------------------------------------

// CfgInfoReq

// optional string session_id = 1;
inline bool CfgInfoReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CfgInfoReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CfgInfoReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CfgInfoReq::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& CfgInfoReq::session_id() const {
  return *session_id_;
}
inline void CfgInfoReq::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void CfgInfoReq::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void CfgInfoReq::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CfgInfoReq::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* CfgInfoReq::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 p1 = 2;
inline bool CfgInfoReq::has_p1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CfgInfoReq::set_has_p1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CfgInfoReq::clear_has_p1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CfgInfoReq::clear_p1() {
  p1_ = 0;
  clear_has_p1();
}
inline ::google::protobuf::int32 CfgInfoReq::p1() const {
  return p1_;
}
inline void CfgInfoReq::set_p1(::google::protobuf::int32 value) {
  set_has_p1();
  p1_ = value;
}

// optional int64 p2 = 3;
inline bool CfgInfoReq::has_p2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CfgInfoReq::set_has_p2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CfgInfoReq::clear_has_p2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CfgInfoReq::clear_p2() {
  p2_ = GOOGLE_LONGLONG(0);
  clear_has_p2();
}
inline ::google::protobuf::int64 CfgInfoReq::p2() const {
  return p2_;
}
inline void CfgInfoReq::set_p2(::google::protobuf::int64 value) {
  set_has_p2();
  p2_ = value;
}

// optional string p3 = 4;
inline bool CfgInfoReq::has_p3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CfgInfoReq::set_has_p3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CfgInfoReq::clear_has_p3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CfgInfoReq::clear_p3() {
  if (p3_ != &::google::protobuf::internal::kEmptyString) {
    p3_->clear();
  }
  clear_has_p3();
}
inline const ::std::string& CfgInfoReq::p3() const {
  return *p3_;
}
inline void CfgInfoReq::set_p3(const ::std::string& value) {
  set_has_p3();
  if (p3_ == &::google::protobuf::internal::kEmptyString) {
    p3_ = new ::std::string;
  }
  p3_->assign(value);
}
inline void CfgInfoReq::set_p3(const char* value) {
  set_has_p3();
  if (p3_ == &::google::protobuf::internal::kEmptyString) {
    p3_ = new ::std::string;
  }
  p3_->assign(value);
}
inline void CfgInfoReq::set_p3(const char* value, size_t size) {
  set_has_p3();
  if (p3_ == &::google::protobuf::internal::kEmptyString) {
    p3_ = new ::std::string;
  }
  p3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CfgInfoReq::mutable_p3() {
  set_has_p3();
  if (p3_ == &::google::protobuf::internal::kEmptyString) {
    p3_ = new ::std::string;
  }
  return p3_;
}
inline ::std::string* CfgInfoReq::release_p3() {
  clear_has_p3();
  if (p3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = p3_;
    p3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string gns_name = 5;
inline bool CfgInfoReq::has_gns_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CfgInfoReq::set_has_gns_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CfgInfoReq::clear_has_gns_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CfgInfoReq::clear_gns_name() {
  if (gns_name_ != &::google::protobuf::internal::kEmptyString) {
    gns_name_->clear();
  }
  clear_has_gns_name();
}
inline const ::std::string& CfgInfoReq::gns_name() const {
  return *gns_name_;
}
inline void CfgInfoReq::set_gns_name(const ::std::string& value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void CfgInfoReq::set_gns_name(const char* value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void CfgInfoReq::set_gns_name(const char* value, size_t size) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CfgInfoReq::mutable_gns_name() {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  return gns_name_;
}
inline ::std::string* CfgInfoReq::release_gns_name() {
  clear_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gns_name_;
    gns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip_port = 6;
inline bool CfgInfoReq::has_ip_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CfgInfoReq::set_has_ip_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CfgInfoReq::clear_has_ip_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CfgInfoReq::clear_ip_port() {
  if (ip_port_ != &::google::protobuf::internal::kEmptyString) {
    ip_port_->clear();
  }
  clear_has_ip_port();
}
inline const ::std::string& CfgInfoReq::ip_port() const {
  return *ip_port_;
}
inline void CfgInfoReq::set_ip_port(const ::std::string& value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void CfgInfoReq::set_ip_port(const char* value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void CfgInfoReq::set_ip_port(const char* value, size_t size) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CfgInfoReq::mutable_ip_port() {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  return ip_port_;
}
inline ::std::string* CfgInfoReq::release_ip_port() {
  clear_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_port_;
    ip_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fd = 7;
inline bool CfgInfoReq::has_fd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CfgInfoReq::set_has_fd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CfgInfoReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CfgInfoReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 CfgInfoReq::fd() const {
  return fd_;
}
inline void CfgInfoReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 8;
inline bool CfgInfoReq::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CfgInfoReq::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CfgInfoReq::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CfgInfoReq::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 CfgInfoReq::req_begin_time() const {
  return req_begin_time_;
}
inline void CfgInfoReq::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// -------------------------------------------------------------------

// CfgInfoResp

// optional int32 ret = 1;
inline bool CfgInfoResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CfgInfoResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CfgInfoResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CfgInfoResp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 CfgInfoResp::ret() const {
  return ret_;
}
inline void CfgInfoResp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional string ret_msg = 2;
inline bool CfgInfoResp::has_ret_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CfgInfoResp::set_has_ret_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CfgInfoResp::clear_has_ret_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CfgInfoResp::clear_ret_msg() {
  if (ret_msg_ != &::google::protobuf::internal::kEmptyString) {
    ret_msg_->clear();
  }
  clear_has_ret_msg();
}
inline const ::std::string& CfgInfoResp::ret_msg() const {
  return *ret_msg_;
}
inline void CfgInfoResp::set_ret_msg(const ::std::string& value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void CfgInfoResp::set_ret_msg(const char* value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void CfgInfoResp::set_ret_msg(const char* value, size_t size) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CfgInfoResp::mutable_ret_msg() {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  return ret_msg_;
}
inline ::std::string* CfgInfoResp::release_ret_msg() {
  clear_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_msg_;
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fd = 3;
inline bool CfgInfoResp::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CfgInfoResp::set_has_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CfgInfoResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CfgInfoResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 CfgInfoResp::fd() const {
  return fd_;
}
inline void CfgInfoResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 4;
inline bool CfgInfoResp::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CfgInfoResp::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CfgInfoResp::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CfgInfoResp::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 CfgInfoResp::req_begin_time() const {
  return req_begin_time_;
}
inline void CfgInfoResp::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// -------------------------------------------------------------------

// LogInfo

// optional string gns_name = 1;
inline bool LogInfo::has_gns_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogInfo::set_has_gns_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogInfo::clear_has_gns_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogInfo::clear_gns_name() {
  if (gns_name_ != &::google::protobuf::internal::kEmptyString) {
    gns_name_->clear();
  }
  clear_has_gns_name();
}
inline const ::std::string& LogInfo::gns_name() const {
  return *gns_name_;
}
inline void LogInfo::set_gns_name(const ::std::string& value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void LogInfo::set_gns_name(const char* value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void LogInfo::set_gns_name(const char* value, size_t size) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_gns_name() {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  return gns_name_;
}
inline ::std::string* LogInfo::release_gns_name() {
  clear_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gns_name_;
    gns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip_port = 2;
inline bool LogInfo::has_ip_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogInfo::set_has_ip_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogInfo::clear_has_ip_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogInfo::clear_ip_port() {
  if (ip_port_ != &::google::protobuf::internal::kEmptyString) {
    ip_port_->clear();
  }
  clear_has_ip_port();
}
inline const ::std::string& LogInfo::ip_port() const {
  return *ip_port_;
}
inline void LogInfo::set_ip_port(const ::std::string& value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void LogInfo::set_ip_port(const char* value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void LogInfo::set_ip_port(const char* value, size_t size) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_ip_port() {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  return ip_port_;
}
inline ::std::string* LogInfo::release_ip_port() {
  clear_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_port_;
    ip_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 3;
inline bool LogInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogInfo::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LogInfo::session_id() const {
  return *session_id_;
}
inline void LogInfo::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LogInfo::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void LogInfo::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* LogInfo::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string log_text = 4;
inline bool LogInfo::has_log_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogInfo::set_has_log_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogInfo::clear_has_log_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogInfo::clear_log_text() {
  if (log_text_ != &::google::protobuf::internal::kEmptyString) {
    log_text_->clear();
  }
  clear_has_log_text();
}
inline const ::std::string& LogInfo::log_text() const {
  return *log_text_;
}
inline void LogInfo::set_log_text(const ::std::string& value) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(value);
}
inline void LogInfo::set_log_text(const char* value) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(value);
}
inline void LogInfo::set_log_text(const char* value, size_t size) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogInfo::mutable_log_text() {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  return log_text_;
}
inline ::std::string* LogInfo::release_log_text() {
  clear_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_text_;
    log_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetLogReq

// optional string session_id = 1;
inline bool GetLogReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLogReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLogReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLogReq::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& GetLogReq::session_id() const {
  return *session_id_;
}
inline void GetLogReq::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void GetLogReq::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void GetLogReq::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogReq::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* GetLogReq::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string gns_name = 2;
inline bool GetLogReq::has_gns_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLogReq::set_has_gns_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLogReq::clear_has_gns_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLogReq::clear_gns_name() {
  if (gns_name_ != &::google::protobuf::internal::kEmptyString) {
    gns_name_->clear();
  }
  clear_has_gns_name();
}
inline const ::std::string& GetLogReq::gns_name() const {
  return *gns_name_;
}
inline void GetLogReq::set_gns_name(const ::std::string& value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void GetLogReq::set_gns_name(const char* value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void GetLogReq::set_gns_name(const char* value, size_t size) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogReq::mutable_gns_name() {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  return gns_name_;
}
inline ::std::string* GetLogReq::release_gns_name() {
  clear_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gns_name_;
    gns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ip_port = 3;
inline bool GetLogReq::has_ip_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLogReq::set_has_ip_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLogReq::clear_has_ip_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLogReq::clear_ip_port() {
  if (ip_port_ != &::google::protobuf::internal::kEmptyString) {
    ip_port_->clear();
  }
  clear_has_ip_port();
}
inline const ::std::string& GetLogReq::ip_port() const {
  return *ip_port_;
}
inline void GetLogReq::set_ip_port(const ::std::string& value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void GetLogReq::set_ip_port(const char* value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void GetLogReq::set_ip_port(const char* value, size_t size) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogReq::mutable_ip_port() {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  return ip_port_;
}
inline ::std::string* GetLogReq::release_ip_port() {
  clear_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_port_;
    ip_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 seq = 4;
inline bool GetLogReq::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLogReq::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLogReq::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLogReq::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 GetLogReq::seq() const {
  return seq_;
}
inline void GetLogReq::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// optional int32 fd = 5;
inline bool GetLogReq::has_fd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLogReq::set_has_fd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLogReq::clear_has_fd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLogReq::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GetLogReq::fd() const {
  return fd_;
}
inline void GetLogReq::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 6;
inline bool GetLogReq::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLogReq::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLogReq::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLogReq::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 GetLogReq::req_begin_time() const {
  return req_begin_time_;
}
inline void GetLogReq::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// -------------------------------------------------------------------

// GetLogRespOld

// optional int32 ret = 1;
inline bool GetLogRespOld::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLogRespOld::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLogRespOld::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLogRespOld::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 GetLogRespOld::ret() const {
  return ret_;
}
inline void GetLogRespOld::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional string ret_msg = 2;
inline bool GetLogRespOld::has_ret_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLogRespOld::set_has_ret_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLogRespOld::clear_has_ret_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLogRespOld::clear_ret_msg() {
  if (ret_msg_ != &::google::protobuf::internal::kEmptyString) {
    ret_msg_->clear();
  }
  clear_has_ret_msg();
}
inline const ::std::string& GetLogRespOld::ret_msg() const {
  return *ret_msg_;
}
inline void GetLogRespOld::set_ret_msg(const ::std::string& value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void GetLogRespOld::set_ret_msg(const char* value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void GetLogRespOld::set_ret_msg(const char* value, size_t size) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogRespOld::mutable_ret_msg() {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  return ret_msg_;
}
inline ::std::string* GetLogRespOld::release_ret_msg() {
  clear_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_msg_;
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string log_text = 3;
inline bool GetLogRespOld::has_log_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLogRespOld::set_has_log_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLogRespOld::clear_has_log_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLogRespOld::clear_log_text() {
  if (log_text_ != &::google::protobuf::internal::kEmptyString) {
    log_text_->clear();
  }
  clear_has_log_text();
}
inline const ::std::string& GetLogRespOld::log_text() const {
  return *log_text_;
}
inline void GetLogRespOld::set_log_text(const ::std::string& value) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(value);
}
inline void GetLogRespOld::set_log_text(const char* value) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(value);
}
inline void GetLogRespOld::set_log_text(const char* value, size_t size) {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  log_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogRespOld::mutable_log_text() {
  set_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    log_text_ = new ::std::string;
  }
  return log_text_;
}
inline ::std::string* GetLogRespOld::release_log_text() {
  clear_has_log_text();
  if (log_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_text_;
    log_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 cur_len = 4;
inline bool GetLogRespOld::has_cur_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLogRespOld::set_has_cur_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLogRespOld::clear_has_cur_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLogRespOld::clear_cur_len() {
  cur_len_ = 0;
  clear_has_cur_len();
}
inline ::google::protobuf::int32 GetLogRespOld::cur_len() const {
  return cur_len_;
}
inline void GetLogRespOld::set_cur_len(::google::protobuf::int32 value) {
  set_has_cur_len();
  cur_len_ = value;
}

// optional int32 fd = 5;
inline bool GetLogRespOld::has_fd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLogRespOld::set_has_fd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLogRespOld::clear_has_fd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLogRespOld::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GetLogRespOld::fd() const {
  return fd_;
}
inline void GetLogRespOld::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 6;
inline bool GetLogRespOld::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLogRespOld::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLogRespOld::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLogRespOld::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 GetLogRespOld::req_begin_time() const {
  return req_begin_time_;
}
inline void GetLogRespOld::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// -------------------------------------------------------------------

// LogText

// optional string ip_port = 1;
inline bool LogText::has_ip_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogText::set_has_ip_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogText::clear_has_ip_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogText::clear_ip_port() {
  if (ip_port_ != &::google::protobuf::internal::kEmptyString) {
    ip_port_->clear();
  }
  clear_has_ip_port();
}
inline const ::std::string& LogText::ip_port() const {
  return *ip_port_;
}
inline void LogText::set_ip_port(const ::std::string& value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void LogText::set_ip_port(const char* value) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(value);
}
inline void LogText::set_ip_port(const char* value, size_t size) {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  ip_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogText::mutable_ip_port() {
  set_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    ip_port_ = new ::std::string;
  }
  return ip_port_;
}
inline ::std::string* LogText::release_ip_port() {
  clear_has_ip_port();
  if (ip_port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_port_;
    ip_port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string gns_name = 2;
inline bool LogText::has_gns_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogText::set_has_gns_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogText::clear_has_gns_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogText::clear_gns_name() {
  if (gns_name_ != &::google::protobuf::internal::kEmptyString) {
    gns_name_->clear();
  }
  clear_has_gns_name();
}
inline const ::std::string& LogText::gns_name() const {
  return *gns_name_;
}
inline void LogText::set_gns_name(const ::std::string& value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void LogText::set_gns_name(const char* value) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(value);
}
inline void LogText::set_gns_name(const char* value, size_t size) {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  gns_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogText::mutable_gns_name() {
  set_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    gns_name_ = new ::std::string;
  }
  return gns_name_;
}
inline ::std::string* LogText::release_gns_name() {
  clear_has_gns_name();
  if (gns_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gns_name_;
    gns_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string text = 3;
inline int LogText::text_size() const {
  return text_.size();
}
inline void LogText::clear_text() {
  text_.Clear();
}
inline const ::std::string& LogText::text(int index) const {
  return text_.Get(index);
}
inline ::std::string* LogText::mutable_text(int index) {
  return text_.Mutable(index);
}
inline void LogText::set_text(int index, const ::std::string& value) {
  text_.Mutable(index)->assign(value);
}
inline void LogText::set_text(int index, const char* value) {
  text_.Mutable(index)->assign(value);
}
inline void LogText::set_text(int index, const char* value, size_t size) {
  text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogText::add_text() {
  return text_.Add();
}
inline void LogText::add_text(const ::std::string& value) {
  text_.Add()->assign(value);
}
inline void LogText::add_text(const char* value) {
  text_.Add()->assign(value);
}
inline void LogText::add_text(const char* value, size_t size) {
  text_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LogText::text() const {
  return text_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LogText::mutable_text() {
  return &text_;
}

// -------------------------------------------------------------------

// GetLogResp

// optional int32 ret = 1;
inline bool GetLogResp::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLogResp::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLogResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLogResp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 GetLogResp::ret() const {
  return ret_;
}
inline void GetLogResp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional string ret_msg = 2;
inline bool GetLogResp::has_ret_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLogResp::set_has_ret_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLogResp::clear_has_ret_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLogResp::clear_ret_msg() {
  if (ret_msg_ != &::google::protobuf::internal::kEmptyString) {
    ret_msg_->clear();
  }
  clear_has_ret_msg();
}
inline const ::std::string& GetLogResp::ret_msg() const {
  return *ret_msg_;
}
inline void GetLogResp::set_ret_msg(const ::std::string& value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void GetLogResp::set_ret_msg(const char* value) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(value);
}
inline void GetLogResp::set_ret_msg(const char* value, size_t size) {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  ret_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetLogResp::mutable_ret_msg() {
  set_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    ret_msg_ = new ::std::string;
  }
  return ret_msg_;
}
inline ::std::string* GetLogResp::release_ret_msg() {
  clear_has_ret_msg();
  if (ret_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ret_msg_;
    ret_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fd = 3;
inline bool GetLogResp::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLogResp::set_has_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLogResp::clear_has_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLogResp::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 GetLogResp::fd() const {
  return fd_;
}
inline void GetLogResp::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// optional int32 req_begin_time = 4;
inline bool GetLogResp::has_req_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLogResp::set_has_req_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLogResp::clear_has_req_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLogResp::clear_req_begin_time() {
  req_begin_time_ = 0;
  clear_has_req_begin_time();
}
inline ::google::protobuf::int32 GetLogResp::req_begin_time() const {
  return req_begin_time_;
}
inline void GetLogResp::set_req_begin_time(::google::protobuf::int32 value) {
  set_has_req_begin_time();
  req_begin_time_ = value;
}

// repeated .pb.LogText log_text = 5;
inline int GetLogResp::log_text_size() const {
  return log_text_.size();
}
inline void GetLogResp::clear_log_text() {
  log_text_.Clear();
}
inline const ::pb::LogText& GetLogResp::log_text(int index) const {
  return log_text_.Get(index);
}
inline ::pb::LogText* GetLogResp::mutable_log_text(int index) {
  return log_text_.Mutable(index);
}
inline ::pb::LogText* GetLogResp::add_log_text() {
  return log_text_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::LogText >&
GetLogResp::log_text() const {
  return log_text_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::LogText >*
GetLogResp::mutable_log_text() {
  return &log_text_;
}

// -------------------------------------------------------------------

// HeartBeatMsg

// optional string reserve = 1;
inline bool HeartBeatMsg::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeatMsg::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeatMsg::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeatMsg::clear_reserve() {
  if (reserve_ != &::google::protobuf::internal::kEmptyString) {
    reserve_->clear();
  }
  clear_has_reserve();
}
inline const ::std::string& HeartBeatMsg::reserve() const {
  return *reserve_;
}
inline void HeartBeatMsg::set_reserve(const ::std::string& value) {
  set_has_reserve();
  if (reserve_ == &::google::protobuf::internal::kEmptyString) {
    reserve_ = new ::std::string;
  }
  reserve_->assign(value);
}
inline void HeartBeatMsg::set_reserve(const char* value) {
  set_has_reserve();
  if (reserve_ == &::google::protobuf::internal::kEmptyString) {
    reserve_ = new ::std::string;
  }
  reserve_->assign(value);
}
inline void HeartBeatMsg::set_reserve(const char* value, size_t size) {
  set_has_reserve();
  if (reserve_ == &::google::protobuf::internal::kEmptyString) {
    reserve_ = new ::std::string;
  }
  reserve_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartBeatMsg::mutable_reserve() {
  set_has_reserve();
  if (reserve_ == &::google::protobuf::internal::kEmptyString) {
    reserve_ = new ::std::string;
  }
  return reserve_;
}
inline ::std::string* HeartBeatMsg::release_reserve() {
  clear_has_reserve();
  if (reserve_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reserve_;
    reserve_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClearSessionReq

// optional string session_id = 1;
inline bool ClearSessionReq::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClearSessionReq::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClearSessionReq::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClearSessionReq::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ClearSessionReq::session_id() const {
  return *session_id_;
}
inline void ClearSessionReq::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClearSessionReq::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClearSessionReq::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClearSessionReq::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ClearSessionReq::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trace_2eproto__INCLUDED
