// **********************************************************************
//
// Copyright (c) 2003-2011 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.4.2
//
// <auto-generated>
//
// Generated from file `LogProxy.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __LogProxy_h__
#define __LogProxy_h__

#include <gns_api_raii.h>
#include <Ice/LocalObjectF.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/Direct.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Log
{

class LogProxy;

}

}

namespace Log
{

class LogProxy;
bool operator==(const LogProxy&, const LogProxy&);
bool operator<(const LogProxy&, const LogProxy&);

}

namespace IceInternal
{

::Ice::Object* upCast(::Log::LogProxy*);
::IceProxy::Ice::Object* upCast(::IceProxy::Log::LogProxy*);

}

namespace Log
{

typedef ::IceInternal::Handle< ::Log::LogProxy> LogProxyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Log::LogProxy> LogProxyPrx;

void __read(::IceInternal::BasicStream*, LogProxyPrx&);
void __patch__LogProxyPtr(void*, ::Ice::ObjectPtr&);

}

namespace Log
{

struct msg
{
    ::std::string ip;
    ::Ice::Int port;
    ::std::string gnsid;
    ::std::string logtext;

    bool operator==(const msg& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ip != __rhs.ip)
        {
            return false;
        }
        if(port != __rhs.port)
        {
            return false;
        }
        if(gnsid != __rhs.gnsid)
        {
            return false;
        }
        if(logtext != __rhs.logtext)
        {
            return false;
        }
        return true;
    }

    bool operator<(const msg& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ip < __rhs.ip)
        {
            return true;
        }
        else if(__rhs.ip < ip)
        {
            return false;
        }
        if(port < __rhs.port)
        {
            return true;
        }
        else if(__rhs.port < port)
        {
            return false;
        }
        if(gnsid < __rhs.gnsid)
        {
            return true;
        }
        else if(__rhs.gnsid < gnsid)
        {
            return false;
        }
        if(logtext < __rhs.logtext)
        {
            return true;
        }
        else if(__rhs.logtext < logtext)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const msg& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const msg& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const msg& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const msg& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Log::msg> msgseq;
void __writemsgseq(::IceInternal::BasicStream*, const ::Log::msg*, const ::Log::msg*);
void __readmsgseq(::IceInternal::BasicStream*, msgseq&);

struct cfg
{
    ::Ice::Int p1;
    ::Ice::Long p2;
    ::std::string p3;

     void reset()
    {
        p1 = 0;
        p2 = 0;
        p3 = "";
    }

    bool operator==(const cfg& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(p1 != __rhs.p1)
        {
            return false;
        }
        if(p2 != __rhs.p2)
        {
            return false;
        }
        if(p3 != __rhs.p3)
        {
            return false;
        }
        return true;
    }

    bool operator<(const cfg& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(p1 < __rhs.p1)
        {
            return true;
        }
        else if(__rhs.p1 < p1)
        {
            return false;
        }
        if(p2 < __rhs.p2)
        {
            return true;
        }
        else if(__rhs.p2 < p2)
        {
            return false;
        }
        if(p3 < __rhs.p3)
        {
            return true;
        }
        else if(__rhs.p3 < p3)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const cfg& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const cfg& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const cfg& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const cfg& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Log::cfg> cfgseq;
void __writecfgseq(::IceInternal::BasicStream*, const ::Log::cfg*, const ::Log::cfg*);
void __readcfgseq(::IceInternal::BasicStream*, cfgseq&);

typedef ::std::vector< ::std::string> los;

struct filter
{
    ::std::string ip;
    ::std::string port;
    ::std::string gnsid;

    bool operator==(const filter& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ip != __rhs.ip)
        {
            return false;
        }
        if(port != __rhs.port)
        {
            return false;
        }
        if(gnsid != __rhs.gnsid)
        {
            return false;
        }
        return true;
    }

    bool operator<(const filter& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ip < __rhs.ip)
        {
            return true;
        }
        else if(__rhs.ip < ip)
        {
            return false;
        }
        if(port < __rhs.port)
        {
            return true;
        }
        else if(__rhs.port < port)
        {
            return false;
        }
        if(gnsid < __rhs.gnsid)
        {
            return true;
        }
        else if(__rhs.gnsid < gnsid)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const filter& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const filter& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const filter& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const filter& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

struct msg2
{
    ::std::string sessionid;
    ::std::string ip;
    ::Ice::Int port;
    ::std::string gnsid;
    ::std::string logtext;

    bool operator==(const msg2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sessionid != __rhs.sessionid)
        {
            return false;
        }
        if(ip != __rhs.ip)
        {
            return false;
        }
        if(port != __rhs.port)
        {
            return false;
        }
        if(gnsid != __rhs.gnsid)
        {
            return false;
        }
        if(logtext != __rhs.logtext)
        {
            return false;
        }
        return true;
    }

    bool operator<(const msg2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sessionid < __rhs.sessionid)
        {
            return true;
        }
        else if(__rhs.sessionid < sessionid)
        {
            return false;
        }
        if(ip < __rhs.ip)
        {
            return true;
        }
        else if(__rhs.ip < ip)
        {
            return false;
        }
        if(port < __rhs.port)
        {
            return true;
        }
        else if(__rhs.port < port)
        {
            return false;
        }
        if(gnsid < __rhs.gnsid)
        {
            return true;
        }
        else if(__rhs.gnsid < gnsid)
        {
            return false;
        }
        if(logtext < __rhs.logtext)
        {
            return true;
        }
        else if(__rhs.logtext < logtext)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const msg2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const msg2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const msg2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const msg2& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Log::msg2> msgseq2;
void __writemsgseq2(::IceInternal::BasicStream*, const ::Log::msg2*, const ::Log::msg2*);
void __readmsgseq2(::IceInternal::BasicStream*, msgseq2&);

struct cfg2
{
    ::std::string sessionid;
    ::Ice::Int p1;
    ::Ice::Long p2;
    ::std::string p3;

    void reset()
    {
        sessionid = "";
        p1 = 0;
        p2 = 0;
        p3 = "";
    }

    bool operator==(const cfg2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sessionid != __rhs.sessionid)
        {
            return false;
        }
        if(p1 != __rhs.p1)
        {
            return false;
        }
        if(p2 != __rhs.p2)
        {
            return false;
        }
        if(p3 != __rhs.p3)
        {
            return false;
        }
        return true;
    }

    bool operator<(const cfg2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sessionid < __rhs.sessionid)
        {
            return true;
        }
        else if(__rhs.sessionid < sessionid)
        {
            return false;
        }
        if(p1 < __rhs.p1)
        {
            return true;
        }
        else if(__rhs.p1 < p1)
        {
            return false;
        }
        if(p2 < __rhs.p2)
        {
            return true;
        }
        else if(__rhs.p2 < p2)
        {
            return false;
        }
        if(p3 < __rhs.p3)
        {
            return true;
        }
        else if(__rhs.p3 < p3)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const cfg2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const cfg2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const cfg2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const cfg2& __rhs) const
    {
        return !operator<(__rhs);
    }

    void __write(::IceInternal::BasicStream*) const;
    void __read(::IceInternal::BasicStream*);
};

typedef ::std::vector< ::Log::cfg2> cfgseq2;
void __writecfgseq2(::IceInternal::BasicStream*, const ::Log::cfg2*, const ::Log::cfg2*);
void __readcfgseq2(::IceInternal::BasicStream*, cfgseq2&);

typedef ::std::vector< ::std::string> stringVec;

}

namespace Log
{

class AMI_LogProxy_getConfig3 : public ::Ice::AMICallbackBase
{
public:

    virtual void ice_response(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&) = 0;

    void __response(::Ice::Int __ret, ::Ice::Long nextcfgid, const ::Log::cfgseq2& cfgs)
    {
        ice_response(__ret, nextcfgid, cfgs);
    }
    void __exception(const ::Ice::Exception& ex)
    {
        ice_exception(ex);
    }
    void __sent(bool sentSynchronously)
    {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        AMICallbackBase::__sent(sentSynchronously);
#else
        ::Ice::AMICallbackBase::__sent(sentSynchronously);
#endif
    }
};

typedef ::IceUtil::Handle< ::Log::AMI_LogProxy_getConfig3> AMI_LogProxy_getConfig3Ptr;

class AMD_LogProxy_getConfig3 : virtual public ::Ice::AMDCallback
{
public:

    virtual void ice_response(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&) = 0;
};

typedef ::IceUtil::Handle< ::Log::AMD_LogProxy_getConfig3> AMD_LogProxy_getConfig3Ptr;

}

namespace IceAsync
{

namespace Log
{

class AMD_LogProxy_getConfig3 : public ::Log::AMD_LogProxy_getConfig3, public ::IceInternal::IncomingAsync
{
public:

    AMD_LogProxy_getConfig3(::IceInternal::Incoming&);

    virtual void ice_response(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&);
};

}

}

namespace Log
{

class Callback_LogProxy_writeConfig_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_writeConfig_Base> Callback_LogProxy_writeConfigPtr;

class Callback_LogProxy_getConfig_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getConfig_Base> Callback_LogProxy_getConfigPtr;

class Callback_LogProxy_writeLogs_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_writeLogs_Base> Callback_LogProxy_writeLogsPtr;

class Callback_LogProxy_getLogs_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getLogs_Base> Callback_LogProxy_getLogsPtr;

class Callback_LogProxy_login_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_login_Base> Callback_LogProxy_loginPtr;

class Callback_LogProxy_GetAllGnsid_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_GetAllGnsid_Base> Callback_LogProxy_GetAllGnsidPtr;

class Callback_LogProxy_GetDescByGnsid_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_GetDescByGnsid_Base> Callback_LogProxy_GetDescByGnsidPtr;

class Callback_LogProxy_GetParmsByGnsidDesc_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_GetParmsByGnsidDesc_Base> Callback_LogProxy_GetParmsByGnsidDescPtr;

class Callback_LogProxy_ShareConfig_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_ShareConfig_Base> Callback_LogProxy_ShareConfigPtr;

class Callback_LogProxy_GetSharedConfigName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_GetSharedConfigName_Base> Callback_LogProxy_GetSharedConfigNamePtr;

class Callback_LogProxy_GetSharedConfigByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_GetSharedConfigByName_Base> Callback_LogProxy_GetSharedConfigByNamePtr;

class Callback_LogProxy_getLogsByFilter_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getLogsByFilter_Base> Callback_LogProxy_getLogsByFilterPtr;

class Callback_LogProxy_writeConfig2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_writeConfig2_Base> Callback_LogProxy_writeConfig2Ptr;

class Callback_LogProxy_getConfig2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getConfig2_Base> Callback_LogProxy_getConfig2Ptr;

class Callback_LogProxy_getConfig3_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getConfig3_Base> Callback_LogProxy_getConfig3Ptr;

class Callback_LogProxy_writeLogs2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_writeLogs2_Base> Callback_LogProxy_writeLogs2Ptr;

class Callback_LogProxy_login2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_login2_Base> Callback_LogProxy_login2Ptr;

class Callback_LogProxy_getLogsBySessionIpPortVec_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_getLogsBySessionIpPortVec_Base> Callback_LogProxy_getLogsBySessionIpPortVecPtr;

class Callback_LogProxy_writeConfig3_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_writeConfig3_Base> Callback_LogProxy_writeConfig3Ptr;

class Callback_LogProxy_setLogProxyLogLevel_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogProxy_setLogProxyLogLevel_Base> Callback_LogProxy_setLogProxyLogLevelPtr;

}

namespace IceProxy
{

namespace Log
{

class LogProxy : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c)
    {
        return writeConfig(cookie, ip, port, c, 0);
    }
    ::Ice::Int writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Ice::Context& __ctx)
    {
        return writeConfig(cookie, ip, port, c, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c)
    {
        return begin_writeConfig(cookie, ip, port, c, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Ice::Context& __ctx)
    {
        return begin_writeConfig(cookie, ip, port, c, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig(cookie, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig(cookie, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Log::Callback_LogProxy_writeConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig(cookie, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg& c, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_writeConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig(cookie, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_writeConfig(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq& cfgs)
    {
        return getConfig(cookie, ip, port, cfgid, nextcfgid, cfgs, 0);
    }
    ::Ice::Int getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq& cfgs, const ::Ice::Context& __ctx)
    {
        return getConfig(cookie, ip, port, cfgid, nextcfgid, cfgs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid)
    {
        return begin_getConfig(cookie, ip, port, cfgid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx)
    {
        return begin_getConfig(cookie, ip, port, cfgid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Log::Callback_LogProxy_getConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getConfig(::Ice::Long& nextcfgid, ::Log::cfgseq& cfgs, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs)
    {
        return writeLogs(cookie, logs, 0);
    }
    ::Ice::Int writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Ice::Context& __ctx)
    {
        return writeLogs(cookie, logs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs)
    {
        return begin_writeLogs(cookie, logs, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Ice::Context& __ctx)
    {
        return begin_writeLogs(cookie, logs, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs(cookie, logs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs(cookie, logs, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Log::Callback_LogProxy_writeLogsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs(cookie, logs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string& cookie, const ::Log::msgseq& logs, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_writeLogsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs(cookie, logs, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_writeLogs(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getLogs(const ::std::string& cookie, ::Ice::Long logid, ::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice)
    {
        return getLogs(cookie, logid, nextlogid, logs, notice, 0);
    }
    ::Ice::Int getLogs(const ::std::string& cookie, ::Ice::Long logid, ::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice, const ::Ice::Context& __ctx)
    {
        return getLogs(cookie, logid, nextlogid, logs, notice, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid)
    {
        return begin_getLogs(cookie, logid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid, const ::Ice::Context& __ctx)
    {
        return begin_getLogs(cookie, logid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogs(cookie, logid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogs(cookie, logid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid, const ::Log::Callback_LogProxy_getLogsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogs(cookie, logid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string& cookie, ::Ice::Long logid, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getLogsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogs(cookie, logid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getLogs(::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getLogs(const ::std::string&, ::Ice::Long, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLogs(const ::std::string&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int login(const ::std::string& version, const ::std::string& pass, ::std::string& cookie)
    {
        return login(version, pass, cookie, 0);
    }
    ::Ice::Int login(const ::std::string& version, const ::std::string& pass, ::std::string& cookie, const ::Ice::Context& __ctx)
    {
        return login(version, pass, cookie, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass)
    {
        return begin_login(version, pass, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx)
    {
        return begin_login(version, pass, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(version, pass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(version, pass, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass, const ::Log::Callback_LogProxy_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(version, pass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(version, pass, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_login(::std::string& cookie, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int login(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_login(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetAllGnsid(const ::std::string& cookie, ::Log::los& ids)
    {
        return GetAllGnsid(cookie, ids, 0);
    }
    ::Ice::Int GetAllGnsid(const ::std::string& cookie, ::Log::los& ids, const ::Ice::Context& __ctx)
    {
        return GetAllGnsid(cookie, ids, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie)
    {
        return begin_GetAllGnsid(cookie, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie, const ::Ice::Context& __ctx)
    {
        return begin_GetAllGnsid(cookie, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetAllGnsid(cookie, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetAllGnsid(cookie, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie, const ::Log::Callback_LogProxy_GetAllGnsidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetAllGnsid(cookie, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string& cookie, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_GetAllGnsidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetAllGnsid(cookie, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetAllGnsid(::Log::los& ids, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetAllGnsid(const ::std::string&, ::Log::los&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetAllGnsid(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, ::Log::los& descs, ::Log::los& edescs)
    {
        return GetDescByGnsid(cookie, gnsid, descs, edescs, 0);
    }
    ::Ice::Int GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, ::Log::los& descs, ::Log::los& edescs, const ::Ice::Context& __ctx)
    {
        return GetDescByGnsid(cookie, gnsid, descs, edescs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid)
    {
        return begin_GetDescByGnsid(cookie, gnsid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, const ::Ice::Context& __ctx)
    {
        return begin_GetDescByGnsid(cookie, gnsid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDescByGnsid(cookie, gnsid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDescByGnsid(cookie, gnsid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, const ::Log::Callback_LogProxy_GetDescByGnsidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDescByGnsid(cookie, gnsid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string& cookie, const ::std::string& gnsid, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_GetDescByGnsidPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDescByGnsid(cookie, gnsid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetDescByGnsid(::Log::los& descs, ::Log::los& edescs, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetDescByGnsid(const ::std::string&, const ::std::string&, ::Log::los&, ::Log::los&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetDescByGnsid(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, ::Log::cfg& c)
    {
        return GetParmsByGnsidDesc(cookie, gnsid, desc, c, 0);
    }
    ::Ice::Int GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, ::Log::cfg& c, const ::Ice::Context& __ctx)
    {
        return GetParmsByGnsidDesc(cookie, gnsid, desc, c, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, const ::Ice::Context& __ctx)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, const ::Log::Callback_LogProxy_GetParmsByGnsidDescPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string& cookie, const ::std::string& gnsid, const ::std::string& desc, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_GetParmsByGnsidDescPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetParmsByGnsidDesc(cookie, gnsid, desc, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetParmsByGnsidDesc(::Log::cfg& c, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, ::Log::cfg&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, ::std::string& error)
    {
        return ShareConfig(cookie, cname, ctext, remark, error, 0);
    }
    ::Ice::Int ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, ::std::string& error, const ::Ice::Context& __ctx)
    {
        return ShareConfig(cookie, cname, ctext, remark, error, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, const ::Ice::Context& __ctx)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, const ::Log::Callback_LogProxy_ShareConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string& cookie, const ::std::string& cname, const ::std::string& ctext, const ::std::string& remark, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_ShareConfigPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ShareConfig(cookie, cname, ctext, remark, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_ShareConfig(::std::string& error, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetSharedConfigName(const ::std::string& cookie, ::Log::los& names)
    {
        return GetSharedConfigName(cookie, names, 0);
    }
    ::Ice::Int GetSharedConfigName(const ::std::string& cookie, ::Log::los& names, const ::Ice::Context& __ctx)
    {
        return GetSharedConfigName(cookie, names, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie)
    {
        return begin_GetSharedConfigName(cookie, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie, const ::Ice::Context& __ctx)
    {
        return begin_GetSharedConfigName(cookie, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigName(cookie, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigName(cookie, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie, const ::Log::Callback_LogProxy_GetSharedConfigNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigName(cookie, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string& cookie, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_GetSharedConfigNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigName(cookie, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetSharedConfigName(::Log::los& names, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetSharedConfigName(const ::std::string&, ::Log::los&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetSharedConfigName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, ::std::string& ctext, ::std::string& remark, ::std::string& mtime)
    {
        return GetSharedConfigByName(cookie, cname, ctext, remark, mtime, 0);
    }
    ::Ice::Int GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, ::std::string& ctext, ::std::string& remark, ::std::string& mtime, const ::Ice::Context& __ctx)
    {
        return GetSharedConfigByName(cookie, cname, ctext, remark, mtime, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname)
    {
        return begin_GetSharedConfigByName(cookie, cname, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, const ::Ice::Context& __ctx)
    {
        return begin_GetSharedConfigByName(cookie, cname, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigByName(cookie, cname, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigByName(cookie, cname, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, const ::Log::Callback_LogProxy_GetSharedConfigByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigByName(cookie, cname, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string& cookie, const ::std::string& cname, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_GetSharedConfigByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetSharedConfigByName(cookie, cname, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetSharedConfigByName(::std::string& ctext, ::std::string& remark, ::std::string& mtime, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetSharedConfigByName(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetSharedConfigByName(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, ::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice)
    {
        return getLogsByFilter(cookie, logid, f, nextlogid, logs, notice, 0);
    }
    ::Ice::Int getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, ::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice, const ::Ice::Context& __ctx)
    {
        return getLogsByFilter(cookie, logid, f, nextlogid, logs, notice, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f)
    {
        return begin_getLogsByFilter(cookie, logid, f, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, const ::Ice::Context& __ctx)
    {
        return begin_getLogsByFilter(cookie, logid, f, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsByFilter(cookie, logid, f, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsByFilter(cookie, logid, f, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, const ::Log::Callback_LogProxy_getLogsByFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsByFilter(cookie, logid, f, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string& cookie, ::Ice::Long logid, const ::Log::filter& f, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getLogsByFilterPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsByFilter(cookie, logid, f, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getLogsByFilter(::Ice::Long& nextlogid, ::Log::msgseq& logs, ::std::string& notice, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c)
    {
        return writeConfig2(cookie, ip, port, c, 0);
    }
    ::Ice::Int writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx)
    {
        return writeConfig2(cookie, ip, port, c, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c)
    {
        return begin_writeConfig2(cookie, ip, port, c, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx)
    {
        return begin_writeConfig2(cookie, ip, port, c, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig2(cookie, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig2(cookie, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Log::Callback_LogProxy_writeConfig2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig2(cookie, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_writeConfig2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig2(cookie, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_writeConfig2(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs)
    {
        return getConfig2(cookie, ip, port, cfgid, nextcfgid, cfgs, 0);
    }
    ::Ice::Int getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs, const ::Ice::Context& __ctx)
    {
        return getConfig2(cookie, ip, port, cfgid, nextcfgid, cfgs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Log::Callback_LogProxy_getConfig2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getConfig2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig2(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getConfig2(::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs)
    {
        return getConfig3(cookie, ip, port, cfgid, nextcfgid, cfgs, 0);
    }
    ::Ice::Int getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, ::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs, const ::Ice::Context& __ctx)
    {
        return getConfig3(cookie, ip, port, cfgid, nextcfgid, cfgs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Log::Callback_LogProxy_getConfig3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string& cookie, const ::std::string& ip, ::Ice::Int port, ::Ice::Long cfgid, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getConfig3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getConfig3(cookie, ip, port, cfgid, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getConfig3(::Ice::Long& nextcfgid, ::Log::cfgseq2& cfgs, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getConfig3(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getConfig3(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    bool getConfig3_async(const ::Log::AMI_LogProxy_getConfig3Ptr&, const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long);
    bool getConfig3_async(const ::Log::AMI_LogProxy_getConfig3Ptr&, const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context&);

    ::Ice::Int writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs)
    {
        return writeLogs2(cookie, logs, 0);
    }
    ::Ice::Int writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Ice::Context& __ctx)
    {
        return writeLogs2(cookie, logs, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs)
    {
        return begin_writeLogs2(cookie, logs, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Ice::Context& __ctx)
    {
        return begin_writeLogs2(cookie, logs, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs2(cookie, logs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs2(cookie, logs, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Log::Callback_LogProxy_writeLogs2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs2(cookie, logs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string& cookie, const ::Log::msgseq2& logs, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_writeLogs2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeLogs2(cookie, logs, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_writeLogs2(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int login2(const ::std::string& version, const ::std::string& pass, ::std::string& cookie, ::std::string& sessionid)
    {
        return login2(version, pass, cookie, sessionid, 0);
    }
    ::Ice::Int login2(const ::std::string& version, const ::std::string& pass, ::std::string& cookie, ::std::string& sessionid, const ::Ice::Context& __ctx)
    {
        return login2(version, pass, cookie, sessionid, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass)
    {
        return begin_login2(version, pass, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx)
    {
        return begin_login2(version, pass, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login2(version, pass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login2(version, pass, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass, const ::Log::Callback_LogProxy_login2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login2(version, pass, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login2(const ::std::string& version, const ::std::string& pass, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_login2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login2(version, pass, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_login2(::std::string& cookie, ::std::string& sessionid, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int login2(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_login2(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, ::Log::msgseq2& logs, ::std::string& notice)
    {
        return getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, logs, notice, 0);
    }
    ::Ice::Int getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, ::Log::msgseq2& logs, ::std::string& notice, const ::Ice::Context& __ctx)
    {
        return getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, logs, notice, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, const ::Ice::Context& __ctx)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, const ::Log::Callback_LogProxy_getLogsBySessionIpPortVecPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string& cookie, const ::Log::stringVec& strSessionVec, const ::Log::stringVec& strIPVec, const ::Log::stringVec& strPortVec, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_getLogsBySessionIpPortVecPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLogsBySessionIpPortVec(cookie, strSessionVec, strIPVec, strPortVec, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getLogsBySessionIpPortVec(::Log::msgseq2& logs, ::std::string& notice, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, ::Log::msgseq2&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c)
    {
        return writeConfig3(cookie, id, ip, port, c, 0);
    }
    ::Ice::Int writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx)
    {
        return writeConfig3(cookie, id, ip, port, c, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Log::Callback_LogProxy_writeConfig3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string& cookie, const ::std::string& id, const ::std::string& ip, ::Ice::Int port, const ::Log::cfg2& c, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_writeConfig3Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_writeConfig3(cookie, id, ip, port, c, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_writeConfig3(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int setLogProxyLogLevel(const ::std::string& level)
    {
        return setLogProxyLogLevel(level, 0);
    }
    ::Ice::Int setLogProxyLogLevel(const ::std::string& level, const ::Ice::Context& __ctx)
    {
        return setLogProxyLogLevel(level, &__ctx);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level)
    {
        return begin_setLogProxyLogLevel(level, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level, const ::Ice::Context& __ctx)
    {
        return begin_setLogProxyLogLevel(level, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLogProxyLogLevel(level, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLogProxyLogLevel(level, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level, const ::Log::Callback_LogProxy_setLogProxyLogLevelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLogProxyLogLevel(level, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string& level, const ::Ice::Context& __ctx, const ::Log::Callback_LogProxy_setLogProxyLogLevelPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLogProxyLogLevel(level, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_setLogProxyLogLevel(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int setLogProxyLogLevel(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLogProxyLogLevel(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<LogProxy> ice_context(const ::Ice::Context& __context) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_context(__context).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_adapterId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_adapterId(__id).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_endpoints(__endpoints).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_locatorCacheTimeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_locatorCacheTimeout(__timeout).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_connectionCached(bool __cached) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_connectionCached(__cached).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_endpointSelection(__est).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_secure(bool __secure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_secure(__secure).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_preferSecure(bool __preferSecure) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_preferSecure(__preferSecure).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_router(const ::Ice::RouterPrx& __router) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_router(__router).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_locator(__locator).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_collocationOptimized(bool __co) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_collocationOptimized(__co).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_twoway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_twoway().get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_twoway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_oneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_oneway().get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_oneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_batchOneway() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_batchOneway().get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_datagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_datagram().get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_datagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_batchDatagram() const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_batchDatagram().get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_compress(bool __compress) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_compress(__compress).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_timeout(int __timeout) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_timeout(__timeout).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    #endif
    }
    
    ::IceInternal::ProxyHandle<LogProxy> ice_connectionId(const std::string& __id) const
    {
    #if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
        typedef ::IceProxy::Ice::Object _Base;
        return dynamic_cast<LogProxy*>(_Base::ice_connectionId(__id).get());
    #else
        return dynamic_cast<LogProxy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    #endif
    }
    
    static const ::std::string& ice_staticId();

public: 

    GNS_API::CALLER m_caller;

    GNS_API::CALLEE m_callee;

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Log
{

class LogProxy : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Ice::Int writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getLogs(const ::std::string&, ::Ice::Long, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int login(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int GetAllGnsid(const ::std::string&, ::Log::los&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int GetDescByGnsid(const ::std::string&, const ::std::string&, ::Log::los&, ::Log::los&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, ::Log::cfg&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int GetSharedConfigName(const ::std::string&, ::Log::los&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int GetSharedConfigByName(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getConfig3(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int login2(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, ::Log::msgseq2&, ::std::string&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*) = 0;

    virtual ::Ice::Int setLogProxyLogLevel(const ::std::string&, const ::Ice::Context*) = 0;
};

}

}

namespace IceDelegateM
{

namespace Log
{

class LogProxy : virtual public ::IceDelegate::Log::LogProxy,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Ice::Int writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq&, const ::Ice::Context*);

    virtual ::Ice::Int writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Context*);

    virtual ::Ice::Int getLogs(const ::std::string&, ::Ice::Long, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int login(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int GetAllGnsid(const ::std::string&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetDescByGnsid(const ::std::string&, const ::std::string&, ::Log::los&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, ::Log::cfg&, const ::Ice::Context*);

    virtual ::Ice::Int ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int GetSharedConfigName(const ::std::string&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetSharedConfigByName(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig3(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int login2(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, ::Log::msgseq2&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);

    virtual ::Ice::Int setLogProxyLogLevel(const ::std::string&, const ::Ice::Context*);
};

}

}

namespace IceDelegateD
{

namespace Log
{

class LogProxy : virtual public ::IceDelegate::Log::LogProxy,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Ice::Int writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq&, const ::Ice::Context*);

    virtual ::Ice::Int writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Context*);

    virtual ::Ice::Int getLogs(const ::std::string&, ::Ice::Long, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int login(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int GetAllGnsid(const ::std::string&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetDescByGnsid(const ::std::string&, const ::std::string&, ::Log::los&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, ::Log::cfg&, const ::Ice::Context*);

    virtual ::Ice::Int ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int GetSharedConfigName(const ::std::string&, ::Log::los&, const ::Ice::Context*);

    virtual ::Ice::Int GetSharedConfigByName(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int getConfig3(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Context*);

    virtual ::Ice::Int login2(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, ::Log::msgseq2&, ::std::string&, const ::Ice::Context*);

    virtual ::Ice::Int writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Context*);

    virtual ::Ice::Int setLogProxyLogLevel(const ::std::string&, const ::Ice::Context*);
};

}

}

namespace Log
{

class LogProxy : virtual public ::Ice::Object
{
public:

    typedef LogProxyPrx ProxyType;
    typedef LogProxyPtr PointerType;
    
    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int writeConfig(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___writeConfig(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getConfig(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getConfig(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int writeLogs(const ::std::string&, const ::Log::msgseq&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___writeLogs(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getLogs(const ::std::string&, ::Ice::Long, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLogs(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int login(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___login(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetAllGnsid(const ::std::string&, ::Log::los&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetAllGnsid(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetDescByGnsid(const ::std::string&, const ::std::string&, ::Log::los&, ::Log::los&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetDescByGnsid(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetParmsByGnsidDesc(const ::std::string&, const ::std::string&, const ::std::string&, ::Log::cfg&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetParmsByGnsidDesc(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int ShareConfig(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ShareConfig(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetSharedConfigName(const ::std::string&, ::Log::los&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetSharedConfigName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetSharedConfigByName(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetSharedConfigByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getLogsByFilter(const ::std::string&, ::Ice::Long, const ::Log::filter&, ::Ice::Long&, ::Log::msgseq&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLogsByFilter(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int writeConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___writeConfig2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getConfig2(const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::Log::cfgseq2&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getConfig2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void getConfig3_async(const ::Log::AMD_LogProxy_getConfig3Ptr&, const ::std::string&, const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getConfig3(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int writeLogs2(const ::std::string&, const ::Log::msgseq2&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___writeLogs2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int login2(const ::std::string&, const ::std::string&, ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___login2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getLogsBySessionIpPortVec(const ::std::string&, const ::Log::stringVec&, const ::Log::stringVec&, const ::Log::stringVec&, ::Log::msgseq2&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLogsBySessionIpPortVec(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int writeConfig3(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Log::cfg2&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___writeConfig3(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int setLogProxyLogLevel(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLogProxyLogLevel(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void __write(::IceInternal::BasicStream*) const;
    virtual void __read(::IceInternal::BasicStream*, bool);
// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
    virtual void __write(const ::Ice::OutputStreamPtr&) const;
    virtual void __read(const ::Ice::InputStreamPtr&, bool);
#endif
};

inline bool operator==(const LogProxy& l, const LogProxy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LogProxy& l, const LogProxy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Log
{

template<class T>
class CallbackNC_LogProxy_writeConfig : public Callback_LogProxy_writeConfig_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_writeConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_writeConfigPtr
newCallback_LogProxy_writeConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_writeConfigPtr
newCallback_LogProxy_writeConfig(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_writeConfig : public Callback_LogProxy_writeConfig_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_writeConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_writeConfigPtr
newCallback_LogProxy_writeConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_writeConfigPtr
newCallback_LogProxy_writeConfig(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getConfig : public Callback_LogProxy_getConfig_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&);

    CallbackNC_LogProxy_getConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nextcfgid, cfgs);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getConfigPtr
newCallback_LogProxy_getConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getConfigPtr
newCallback_LogProxy_getConfig(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getConfig : public Callback_LogProxy_getConfig_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&, const CT&);

    Callback_LogProxy_getConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getConfigPtr
newCallback_LogProxy_getConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getConfigPtr
newCallback_LogProxy_getConfig(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_writeLogs : public Callback_LogProxy_writeLogs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_writeLogs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeLogs(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_writeLogsPtr
newCallback_LogProxy_writeLogs(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeLogs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_writeLogsPtr
newCallback_LogProxy_writeLogs(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeLogs<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_writeLogs : public Callback_LogProxy_writeLogs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_writeLogs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeLogs(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_writeLogsPtr
newCallback_LogProxy_writeLogs(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeLogs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_writeLogsPtr
newCallback_LogProxy_writeLogs(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeLogs<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getLogs : public Callback_LogProxy_getLogs_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&);

    CallbackNC_LogProxy_getLogs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextlogid;
        ::Log::msgseq logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogs(nextlogid, logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextlogid, logs, notice);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nextlogid, logs, notice);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getLogsPtr
newCallback_LogProxy_getLogs(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getLogsPtr
newCallback_LogProxy_getLogs(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogs<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getLogs : public Callback_LogProxy_getLogs_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&);

    Callback_LogProxy_getLogs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextlogid;
        ::Log::msgseq logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogs(nextlogid, logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextlogid, logs, notice, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nextlogid, logs, notice, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getLogsPtr
newCallback_LogProxy_getLogs(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getLogsPtr
newCallback_LogProxy_getLogs(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogs<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_login : public Callback_LogProxy_login_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&);

    CallbackNC_LogProxy_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string cookie;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_login(cookie, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cookie);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cookie);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_loginPtr
newCallback_LogProxy_login(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_login<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_loginPtr
newCallback_LogProxy_login(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_login<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_login : public Callback_LogProxy_login_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const CT&);

    Callback_LogProxy_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string cookie;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_login(cookie, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cookie, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cookie, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_loginPtr
newCallback_LogProxy_login(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_loginPtr
newCallback_LogProxy_login(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_GetAllGnsid : public Callback_LogProxy_GetAllGnsid_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&);

    CallbackNC_LogProxy_GetAllGnsid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los ids;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetAllGnsid(ids, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, ids);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, ids);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_GetAllGnsidPtr
newCallback_LogProxy_GetAllGnsid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetAllGnsid<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_GetAllGnsidPtr
newCallback_LogProxy_GetAllGnsid(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetAllGnsid<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_GetAllGnsid : public Callback_LogProxy_GetAllGnsid_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&, const CT&);

    Callback_LogProxy_GetAllGnsid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los ids;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetAllGnsid(ids, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, ids, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, ids, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_GetAllGnsidPtr
newCallback_LogProxy_GetAllGnsid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetAllGnsid<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_GetAllGnsidPtr
newCallback_LogProxy_GetAllGnsid(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetAllGnsid<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_GetDescByGnsid : public Callback_LogProxy_GetDescByGnsid_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&, const ::Log::los&);

    CallbackNC_LogProxy_GetDescByGnsid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los descs;
        ::Log::los edescs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetDescByGnsid(descs, edescs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, descs, edescs);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, descs, edescs);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_GetDescByGnsidPtr
newCallback_LogProxy_GetDescByGnsid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetDescByGnsid<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_GetDescByGnsidPtr
newCallback_LogProxy_GetDescByGnsid(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetDescByGnsid<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_GetDescByGnsid : public Callback_LogProxy_GetDescByGnsid_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&, const ::Log::los&, const CT&);

    Callback_LogProxy_GetDescByGnsid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los descs;
        ::Log::los edescs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetDescByGnsid(descs, edescs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, descs, edescs, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, descs, edescs, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_GetDescByGnsidPtr
newCallback_LogProxy_GetDescByGnsid(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetDescByGnsid<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_GetDescByGnsidPtr
newCallback_LogProxy_GetDescByGnsid(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetDescByGnsid<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_GetParmsByGnsidDesc : public Callback_LogProxy_GetParmsByGnsidDesc_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::Log::cfg&);

    CallbackNC_LogProxy_GetParmsByGnsidDesc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::cfg c;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetParmsByGnsidDesc(c, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, c);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, c);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_GetParmsByGnsidDescPtr
newCallback_LogProxy_GetParmsByGnsidDesc(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::cfg&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetParmsByGnsidDesc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_GetParmsByGnsidDescPtr
newCallback_LogProxy_GetParmsByGnsidDesc(T* instance, void (T::*cb)(::Ice::Int, const ::Log::cfg&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetParmsByGnsidDesc<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_GetParmsByGnsidDesc : public Callback_LogProxy_GetParmsByGnsidDesc_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::Log::cfg&, const CT&);

    Callback_LogProxy_GetParmsByGnsidDesc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::cfg c;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetParmsByGnsidDesc(c, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, c, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, c, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_GetParmsByGnsidDescPtr
newCallback_LogProxy_GetParmsByGnsidDesc(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::cfg&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetParmsByGnsidDesc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_GetParmsByGnsidDescPtr
newCallback_LogProxy_GetParmsByGnsidDesc(T* instance, void (T::*cb)(::Ice::Int, const ::Log::cfg&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetParmsByGnsidDesc<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_ShareConfig : public Callback_LogProxy_ShareConfig_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&);

    CallbackNC_LogProxy_ShareConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string error;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_ShareConfig(error, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, error);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, error);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_ShareConfigPtr
newCallback_LogProxy_ShareConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_ShareConfig<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_ShareConfigPtr
newCallback_LogProxy_ShareConfig(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_ShareConfig<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_ShareConfig : public Callback_LogProxy_ShareConfig_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const CT&);

    Callback_LogProxy_ShareConfig(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string error;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_ShareConfig(error, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, error, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, error, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_ShareConfigPtr
newCallback_LogProxy_ShareConfig(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_ShareConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_ShareConfigPtr
newCallback_LogProxy_ShareConfig(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_ShareConfig<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_GetSharedConfigName : public Callback_LogProxy_GetSharedConfigName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&);

    CallbackNC_LogProxy_GetSharedConfigName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los names;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetSharedConfigName(names, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, names);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, names);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_GetSharedConfigNamePtr
newCallback_LogProxy_GetSharedConfigName(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetSharedConfigName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_GetSharedConfigNamePtr
newCallback_LogProxy_GetSharedConfigName(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetSharedConfigName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_GetSharedConfigName : public Callback_LogProxy_GetSharedConfigName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::Log::los&, const CT&);

    Callback_LogProxy_GetSharedConfigName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::los names;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetSharedConfigName(names, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, names, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, names, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_GetSharedConfigNamePtr
newCallback_LogProxy_GetSharedConfigName(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetSharedConfigName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_GetSharedConfigNamePtr
newCallback_LogProxy_GetSharedConfigName(T* instance, void (T::*cb)(::Ice::Int, const ::Log::los&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetSharedConfigName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_GetSharedConfigByName : public Callback_LogProxy_GetSharedConfigByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&);

    CallbackNC_LogProxy_GetSharedConfigByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string ctext;
        ::std::string remark;
        ::std::string mtime;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetSharedConfigByName(ctext, remark, mtime, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, ctext, remark, mtime);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, ctext, remark, mtime);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_GetSharedConfigByNamePtr
newCallback_LogProxy_GetSharedConfigByName(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetSharedConfigByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_GetSharedConfigByNamePtr
newCallback_LogProxy_GetSharedConfigByName(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_GetSharedConfigByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_GetSharedConfigByName : public Callback_LogProxy_GetSharedConfigByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&, const CT&);

    Callback_LogProxy_GetSharedConfigByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string ctext;
        ::std::string remark;
        ::std::string mtime;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetSharedConfigByName(ctext, remark, mtime, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, ctext, remark, mtime, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, ctext, remark, mtime, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_GetSharedConfigByNamePtr
newCallback_LogProxy_GetSharedConfigByName(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetSharedConfigByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_GetSharedConfigByNamePtr
newCallback_LogProxy_GetSharedConfigByName(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_GetSharedConfigByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getLogsByFilter : public Callback_LogProxy_getLogsByFilter_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&);

    CallbackNC_LogProxy_getLogsByFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextlogid;
        ::Log::msgseq logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogsByFilter(nextlogid, logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextlogid, logs, notice);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nextlogid, logs, notice);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getLogsByFilterPtr
newCallback_LogProxy_getLogsByFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogsByFilter<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getLogsByFilterPtr
newCallback_LogProxy_getLogsByFilter(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogsByFilter<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getLogsByFilter : public Callback_LogProxy_getLogsByFilter_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&);

    Callback_LogProxy_getLogsByFilter(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextlogid;
        ::Log::msgseq logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogsByFilter(nextlogid, logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextlogid, logs, notice, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nextlogid, logs, notice, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getLogsByFilterPtr
newCallback_LogProxy_getLogsByFilter(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogsByFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getLogsByFilterPtr
newCallback_LogProxy_getLogsByFilter(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::msgseq&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogsByFilter<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_writeConfig2 : public Callback_LogProxy_writeConfig2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_writeConfig2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig2(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_writeConfig2Ptr
newCallback_LogProxy_writeConfig2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_writeConfig2Ptr
newCallback_LogProxy_writeConfig2(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_writeConfig2 : public Callback_LogProxy_writeConfig2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_writeConfig2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig2(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_writeConfig2Ptr
newCallback_LogProxy_writeConfig2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_writeConfig2Ptr
newCallback_LogProxy_writeConfig2(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getConfig2 : public Callback_LogProxy_getConfig2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&);

    CallbackNC_LogProxy_getConfig2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq2 cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig2(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nextcfgid, cfgs);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getConfig2Ptr
newCallback_LogProxy_getConfig2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getConfig2Ptr
newCallback_LogProxy_getConfig2(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getConfig2 : public Callback_LogProxy_getConfig2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&);

    Callback_LogProxy_getConfig2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq2 cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig2(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getConfig2Ptr
newCallback_LogProxy_getConfig2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getConfig2Ptr
newCallback_LogProxy_getConfig2(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getConfig3 : public Callback_LogProxy_getConfig3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&);

    CallbackNC_LogProxy_getConfig3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq2 cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig3(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, nextcfgid, cfgs);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getConfig3Ptr
newCallback_LogProxy_getConfig3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig3<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getConfig3Ptr
newCallback_LogProxy_getConfig3(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getConfig3<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getConfig3 : public Callback_LogProxy_getConfig3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&);

    Callback_LogProxy_getConfig3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long nextcfgid;
        ::Log::cfgseq2 cfgs;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getConfig3(nextcfgid, cfgs, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, nextcfgid, cfgs, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getConfig3Ptr
newCallback_LogProxy_getConfig3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig3<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getConfig3Ptr
newCallback_LogProxy_getConfig3(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::Log::cfgseq2&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getConfig3<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_writeLogs2 : public Callback_LogProxy_writeLogs2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_writeLogs2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeLogs2(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_writeLogs2Ptr
newCallback_LogProxy_writeLogs2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeLogs2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_writeLogs2Ptr
newCallback_LogProxy_writeLogs2(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeLogs2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_writeLogs2 : public Callback_LogProxy_writeLogs2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_writeLogs2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeLogs2(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_writeLogs2Ptr
newCallback_LogProxy_writeLogs2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeLogs2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_writeLogs2Ptr
newCallback_LogProxy_writeLogs2(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeLogs2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_login2 : public Callback_LogProxy_login2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&);

    CallbackNC_LogProxy_login2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string cookie;
        ::std::string sessionid;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_login2(cookie, sessionid, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cookie, sessionid);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, cookie, sessionid);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_login2Ptr
newCallback_LogProxy_login2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_login2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_login2Ptr
newCallback_LogProxy_login2(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_login2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_login2 : public Callback_LogProxy_login2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&);

    Callback_LogProxy_login2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::std::string cookie;
        ::std::string sessionid;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_login2(cookie, sessionid, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, cookie, sessionid, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, cookie, sessionid, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_login2Ptr
newCallback_LogProxy_login2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_login2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_login2Ptr
newCallback_LogProxy_login2(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_login2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_getLogsBySessionIpPortVec : public Callback_LogProxy_getLogsBySessionIpPortVec_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&);

    CallbackNC_LogProxy_getLogsBySessionIpPortVec(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::msgseq2 logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogsBySessionIpPortVec(logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, logs, notice);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret, logs, notice);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_getLogsBySessionIpPortVecPtr
newCallback_LogProxy_getLogsBySessionIpPortVec(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogsBySessionIpPortVec<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_getLogsBySessionIpPortVecPtr
newCallback_LogProxy_getLogsBySessionIpPortVec(T* instance, void (T::*cb)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_getLogsBySessionIpPortVec<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_getLogsBySessionIpPortVec : public Callback_LogProxy_getLogsBySessionIpPortVec_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&, const CT&);

    Callback_LogProxy_getLogsBySessionIpPortVec(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Log::msgseq2 logs;
        ::std::string notice;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getLogsBySessionIpPortVec(logs, notice, __result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, logs, notice, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, logs, notice, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_getLogsBySessionIpPortVecPtr
newCallback_LogProxy_getLogsBySessionIpPortVec(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogsBySessionIpPortVec<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_getLogsBySessionIpPortVecPtr
newCallback_LogProxy_getLogsBySessionIpPortVec(T* instance, void (T::*cb)(::Ice::Int, const ::Log::msgseq2&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_getLogsBySessionIpPortVec<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_writeConfig3 : public Callback_LogProxy_writeConfig3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_writeConfig3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig3(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_writeConfig3Ptr
newCallback_LogProxy_writeConfig3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig3<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_writeConfig3Ptr
newCallback_LogProxy_writeConfig3(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_writeConfig3<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_writeConfig3 : public Callback_LogProxy_writeConfig3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_writeConfig3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_writeConfig3(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_writeConfig3Ptr
newCallback_LogProxy_writeConfig3(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig3<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_writeConfig3Ptr
newCallback_LogProxy_writeConfig3(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_writeConfig3<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogProxy_setLogProxyLogLevel : public Callback_LogProxy_setLogProxyLogLevel_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogProxy_setLogProxyLogLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setLogProxyLogLevel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret);
#else
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
#endif
        }
    }

    Response response;
};

template<class T> Callback_LogProxy_setLogProxyLogLevelPtr
newCallback_LogProxy_setLogProxyLogLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_setLogProxyLogLevel<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogProxy_setLogProxyLogLevelPtr
newCallback_LogProxy_setLogProxyLogLevel(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogProxy_setLogProxyLogLevel<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogProxy_setLogProxyLogLevel : public Callback_LogProxy_setLogProxyLogLevel_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogProxy_setLogProxyLogLevel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Log::LogProxyPrx __proxy = ::Log::LogProxyPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_setLogProxyLogLevel(__result);
        }
        catch(::Ice::Exception& ex)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            __exception(__result, ex);
#else
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
#endif
            return;
        }
        if(response)
        {
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
            (callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#else
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
#endif
        }
    }

    Response response;
};

template<class T, typename CT> Callback_LogProxy_setLogProxyLogLevelPtr
newCallback_LogProxy_setLogProxyLogLevel(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_setLogProxyLogLevel<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogProxy_setLogProxyLogLevelPtr
newCallback_LogProxy_setLogProxyLogLevel(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogProxy_setLogProxyLogLevel<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
